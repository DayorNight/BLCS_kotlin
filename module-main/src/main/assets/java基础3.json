{
	"code": 200,
	"message": "",
	"body": [
		{
			"title": "JAVA基础",
			"problem": "Collection 和 Collections的区别？",
			"answer": "1.Collection是集合类的上级接口，常见子类主要有Set 和List. \n2.Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作"
		},{
			"title": "JAVA基础",
			"problem": "final, finally, finalize的区别 ？",
			"answer": "1.final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 \n2.finally是异常处理语句结构的一部分，表示总是执行。 \n3.finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。"
		},{
			"title": "JAVA基础",
			"problem": "什么是反射？",
			"answer": "1：什么是反射（Reflection ）？ 主要是指程序可以访问、检测和修改它本身状态或行为的一种能力\n \t2：什么是Java反射？Java反射指的是在Java程序运行状态中，对于任何一个类，都可以获得这个类的所有属性和方法；对于给定的一个对象，都能够调用它的任意一个属性和方法。这种动态获取类的内容以及动态调用对象的方法称为反射机制。"
		},{
			"title": "JAVA基础",
			"problem": "什么是泛型？",
			"answer": "1：泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明\n2：一般的类和方法，只能使用具体的类型，要么是基础数据类型，要么是自定义类。如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大。而泛型适合用于许多类型。"
		},{
			"title": "JAVA基础",
			"problem": "有哪几种引用类型？",
			"answer": "1.强引用：引用变量指向时永远不会被垃圾回收，虚拟机宁愿抛出内存溢出错误也不会回收这种对象。\n2.软引用：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用\n3.弱引用：弱引用也是用来描述非必需对象的，当虚拟机进行垃圾回收时，无论内存是否充足，都会回收这些弱引用的对象\n4.虚引用：虚引用和软引用、弱引用不同，它并不影响对象的生命周期。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。"
		},{
			"title": "JAVA基础",
			"problem": "介绍一下单例中使用枚举的实现原理？",
			"answer": "1.JVM级别的线程安全：反编译的代码中可以发现枚举中的各个枚举项都是通过static代码块来定义和初始化的，他们会在类被加载时完成初始化，而Java的类加载由JVM保证线程安全。\n2.防止反序列化的破坏：Java的序列化专门对枚举的序列化做了规定，在序列化时，只是将枚举对象的name属性输出到结果中，在反序列化时通过java.lang.Enum的valueOf方法根据名字查找对象，而不是新建一个新的对象，所以防止了反序列化对单例的破坏。\n3.防止反射的破坏：对于反射，枚举类同样有防御措施，反射在通过newInstance创建对象时会检查这个类是否是枚举类，如果是枚举类就会throw new IllegalArgumentException(\"Cannot reflectively create enum objects\");\n缺点:(1)不可继承。Enum的本质语义是把一个类的多个实例直接列举出来.而继承是类的行为, 不是实例的行为.(2)所有的属性都必须在创建时指定, 也就意味着不能延迟加载; 并且使用枚举时占用的内存比静态变量的2倍还多。"
		},{
			"title": "JAVA基础",
			"problem": "介绍一下static的用法？",
			"answer": "static是java中非常重要的一个关键字，而且它的用法也很丰富，主要有5种用法：\n(1)用来修饰成员变量，将其变为类的成员，从而实现所有对象对于该成员的共享；\n(2)用来修饰成员方法，将其变为类方法，可以直接使用“类名.方法名”的方式调用，常用于工具类；\n(3)静态块用法，将多个类成员放在一起初始化，使得程序更加规整，其中理解对象的初始化过程非常关键；\n(4)静态导包用法，将类的方法直接导入到当前类中，从而直接使用“方法名”即可调用类方法，更加方便。\n(5)静态内部类\n     1.静态内部类无需依赖于外部类,它可以独立于外部对象而存在。\n     2.静态内部类,多个外部类的对象可以共享同一个内部类的对象。\n     3.使用静态内部类的好处是加强了封装性以及提高了可读性。"
		},{
			"title": "JAVA基础",
			"problem": "一个类能不能多继承，能不能实现多个接口，为什么？",
			"answer": "1.类之间仅单继承，不能多继承：子类如果能继承多个父类，如果多个父类中存在同名属性或者方法，子类继承时将不能判断继承自哪个父类的属性和方法，所以类之间不能多继承。\n2.接口之间可以多继承：接口中的方法均为抽象方法，没有具体实现的方法体，所以在多继承的情况下，即使方法同名，也不会出现类多继承那样的矛盾。\n3.类与接口之间可以多实现：与接口之间可多继承的原因同理。接口的抽象方法没有具体的方法体，多接口即使拥有同名的抽象方法，类在实现时只需重写一个方法即可"
		},{
			"title": "JAVA基础",
			"problem": "接口类的非方法能不能被修改？",
			"answer": "不能 ，所有成员属性 都用static final 修饰都是常量  。如果可以修改 ，多实现 则会导致属性随意更改没有安全性。"
		},{
			"title": "JAVA基础",
			"problem": "子类继承父类执行顺序？",
			"answer": "1.父类的静态代码；2.子类的静态代码；3.子类的构造方法会隐式的调用父类的构造方法；4.执行父类的构造方法会导致先执行父类的非静态代码块；5.执行父类的构造方法；6.执行子类的构造方法；7.执行子类的非静态代码块；8.执行子类的构造方法；"
		},{
			"title": "JAVA基础",
			"problem": "什么是注解？",
			"answer": "从JDK5开始,Java增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。"
		},{
			"title": "JAVA基础",
			"problem": "char能否定义一个中文？",
			"answer": "这个问题点有3个考核点。1 char是多少位的  2 java用的是什么方式表示字符  3 Unicode是用多少位表示的\n1的答案是16位的，2的答案是Unicode，3的答案是16位。值得注意的是，2的答案并不是utf-8。\nUnicode字符集有包含中文，并且char类型和Unicode类型是相同存储长度的，所以char是可以表示中文的。"
		},{
			"title": "JAVA基础",
			"problem": "死锁 ?怎么产生?几种类型？死锁的四个条件？",
			"answer": "1.什么是死锁：死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。\n2.死锁产生的原因（1）系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。（2） 进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。\n3.产生死锁的四个必要条件\n（1）互斥条件：一个资源每次只能被一个进程使用。此时若有其他进程请求该资源，则请求进程只能等待。\n（2）请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n（3）不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。\n（4）循环等待条件: 若干进程间形成首尾相接循环等待资源的关系\n这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。\n4.死锁的避免与预防\n（1）死锁避免的基本思想:系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配。这是一种保证系统不进入死锁状态的动态策略。理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。死锁避免和死锁预防的区别：死锁预防是设法至少破坏产生死锁的四个必要条件之一,严格的防止死锁的出现,而死锁避免则不那么严格的限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁。死锁避免是在系统运行过程中注意避免死锁的最终发生"
		},{
			"title": "JAVA基础",
			"problem": "继承和接口，优先使用级？",
			"answer": "继承与实现的优先级(1)格式:(继承和实现可以同时存在)\npublic class 子类/实现类 extends 父类 implements 接口,...{\\}\n(2) 继承的优先级 高于 实现,所以必须先extends后implements"
		},{
			"title": "JAVA基础",
			"problem": "数据库的范式，事务的特性？",
			"answer": "第一范式:原子性:是指每列的数据不能再分裂出其他的列\n例如:联系人的中的姓名,电话,性别,其中电话不属于第一范式,要属于第一范式的话就要对电话在进一步分裂(姓名,性别,手机,家庭电话)\n第二范式:在满足第一范式的情况下,每一列的数据都与主键有关系\n例如:订单的编号,生产编号,价格,生产日期,其中生产编号与订单的信息没有直接关系所以可以去掉\n第三范式:在满足第二范式的情况下,所有的列都与主键有关(这个关系是指全部满足对主键的关系而不是部分)也不依赖于其他主键,例如订单的信息(订单号,产品,单价,顾客姓名,顾客编码),其中顾客姓名与顾客编码相关所以应该吧顾客姓名去除\n总结:1.每列的数据不能再分裂出其他的列2.每列都与主键有关系3.确保每列都与主键有着直接的关系而不是间接关系\n事务的4个特性:\nA:原子性(Atomicity):事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。\nB:一致性(Consistency): 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\nC:隔离性(Isolation): 一个事务的执行不能被其他事务干扰。\nD:持续性/永久性(Durability): 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。"
		},{
			"title": "JAVA基础",
			"problem": "常见的对称加密算法和非对称加密算法有哪些？",
			"answer": "(1)常见的对称加密算法：\n1、DES（Data Encryption Standard）:数据加密标准，速度较快，适用于加密大量数据的场合；\n2、3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度较高；\n2、AES（Advanced Encryption Standard）:高级加密标准，是下一代的加密算法标准，速度快，安全级别高。\n3、RC5：分组加密算法，通过异或，加与循环操作加密，是对称的。\n(2)常见的非对称加密算法：\n1、RSA：：由RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；\n2、DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的DSS（数字签名标准）；\n3、ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码学。"
		},{
			"title": "JAVA基础",
			"problem": "静态内部类是怎么保证线程安全的？",
			"answer": "虚拟机会保证一个类的静态方法在多线程环境中被正确的加锁、同步，如果多个线程同事去初始化一个静态类，那么只有一个线程去执行这个类的静态方法，其他线程都需要阻塞等待，直到活动线程执行静态方法执行完毕。如果在一个类的静态方法中有耗时很长的操作，就可能导致多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。"
		},{
			"title": "JAVA基础",
			"problem": "内部类 怎么造成 内存泄漏？",
			"answer": "从反编译的结果得知，内部类的实现其实是通过编译器的语法糖实现的，通过生成相应的子类，并添加构造函数，在构造函数中传入外部类，这也是为什么内部类能使用外部类的方法与字段的原因。也就是内部类持有外部列的强引用。当外部类与内部类生命周期不一致的时候很有可能发生内存泄漏"
		},{
			"title": "JAVA基础",
			"problem": "内部类为什么能访问外部类的变量？",
			"answer": "1.内部类对象的创建依赖于外部类对象；2.内部类对象持有指向外部类对象的引用。"
		},{
			"title": "JAVA基础",
			"problem": "内部类 为什么还能访问外部类的私有变量？",
			"answer": "编译器会在内部类创建一个构造函数，并将外部类传递给内部类。内部类持有外部类的引用，内部类调用外部类的属性，其实是编译器调用外部类获取属性。"
		},{
			"title": "JAVA基础",
			"problem": "介绍一下内存空间分配？java内存模型？",
			"answer": "根据java虚拟机规范，java虚拟机管理的内存将分为下面五大区域。\n1.程序计数器：程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。\n（1）为什么需要程序计数器：我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。\n注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native，那么计数器为空。这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域。\n2.Java栈（虚拟机栈）：同计数器也为线程私有，生命周期与相同，就是我们平时说的栈，栈描述的是Java方法执行的内存模型。每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。对于栈帧的解释参考 Java虚拟机运行时栈帧结构（1）栈帧: 是用来存储数据和部分过程结果的数据结构（2）栈帧的位置:  内存 -> 运行时数据区 -> 某个线程对应的虚拟机栈 -> here[在这里]（3）栈帧大小确定时间: 编译期确定，不受运行期数据影响。通常有人将java内存区分为栈和堆，实际上java内存比这复杂，这么区分可能是因为我们最关注，与对象内存分配关系最密切的是这两个。平时说的栈一般指局部变量表部分。\n局部变量表：一片连续的内存空间，用来存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(reference类型),returnAddress类型。它的最小的局部变量表空间单位为Slot，虚拟机没有指明Slot的大小，但在jvm中，long和double类型数据明确规定为64位，这两个类型占2个Slot，其它基本类型固定占用1个Slot。\nreference类型:与基本类型不同的是它不等同本身，即使是String，内部也是char数组组成，它可能是指向一个对象起始位置指针，也可能指向一个代表对象的句柄或其他与该对象有关的位置。\n3.本地方法栈：本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。\n4.堆：对于大多数应用来说，堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制。因此需要重点了解下。java虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。\n5.方法区：方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。\n运行时常量池：是方法区的一部分，class文件除了有类的字段/接口/方法等描述信息之外，还有常量池用于存放编译期间生成的各种变量和符号引用。"
		},{
			"title": "JAVA基础",
			"problem": "LRU缓存原理？",
			"answer": "LRU(Least Recently Used)  LRU是近期最少使用的算法，它的核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。采用LRU算法的缓存有两种：LrhCache和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。\n（1）LruCache的介绍：LruCache是个泛型类，主要算法原理是把最近使用的对象用强引用（即我们平常使用的对象引用方式）存储在 LinkedHashMap 中。当缓存满时，把最近最少使用的对象从内存中移除，并提供了get和put方法来完成缓存的获取和添加操作。（2）LruCache的实现原理：LruCache的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象，将放在队首，即将被淘汰。而最近访问的对象将放在队头，最后被淘汰。（3）总结：由此可见LruCache中维护了一个集合LinkedHashMap，该LinkedHashMap是以访问顺序排序的。当调用put()方法时，就会在结合中添加元素，并调用trimToSize()判断缓存是否已满，如果满了就用LinkedHashMap的迭代器删除队尾元素，即近期最少访问的元素。当调用get()方法访问缓存对象时，就会调用LinkedHashMap的get()方法获得对应集合元素，同时会更新该元素到队头。"
		},{
			"title": "JAVA基础",
			"problem": "GC机制？",
			"answer": "（1）是一种自动的存储管理机制，它是Java语言的一大特性，方便了我们这些程序员编码，把内存释放工作的压力都转让到了系统，故而是以消耗系统性能为代价的。\n（2）GC主要的一个流程是：先根据一定的算法判定某个对象是否可回收，然后再根据相应的算法把对没用的对象进行回收。\n（3）目前市面上判断对象是否回收的方法有两种：引用计数算法、 Root可达性分析算法。\n一、引用计数算法 \n1.首先给每一个对象都添加一个引用计数器\t\n2.当程序的某一个地方引用了此对象，这个计数器的值就加1\t\t\n3.当引用失效的时候（例如超过了作用域），这个计数器就减1\n4.当某一个对象的计数器的值是0的时候，则判定这个对象不可能被使用\n这种算法对于系统来说比较简单，高效，垃圾回收器运行较快，不需要长时间中断我们的程序的执行，但是缺点是很难处理循环引用，这就导致相互引用的对象都无法被回收：\n二、root可达性分析算法\n1.以称作“GC Root”的对象作为起点向下搜索\n2.每走过一个对象，就生成一条引用链\n3.从根开始到搜索完，生成了一棵引用树，那些到GC Root不可达的对象就是可以回收的\n（4）当判定是可回收对象后，系统就要开始进行回收，系统的垃圾回收算法有以下几种：\n1.标记清除算法(Mark-Sweep)：算法是先进行标记，然后进行清除。缺点：把内存区域弄得非常不完整，形成了很多碎片化的内存\n2.复制算法(Copying)：是对标记清除算法而导致内存碎片化的一个解决方案，复制算法将内存平均分成两个区域，将A中的存活的那些对象复制到B区域中，然后将A区域的所有对象都清除，这样A区域就是一个完整的内存块了，也就避免了内，存碎片化了。缺点：能够真正使用的内存变成了一半\n3.标记整理算法(Mark-Compact)：第一步也需要进行存活对象的一个标记，这一步与标记清除算法一模一样，将存活的对象向一端移动，例如图中是往左上角那一端进行移动，然后把另一端的内存进行清理。缺点：效率降低\n4.分代回收算法：是其他算法的整合。根据不同的情况，采用上面几种方法中合适的一种进行回收垃圾回收。"
		}
	]
}
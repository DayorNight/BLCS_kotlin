{
	"code": 200,
	"message": "",
	"body": [
		{	
			"title": "JAVA进程与线程",
			"problem": "进程间的几种通信方式？",
			"answer": "1.管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。管道分为pipe（无名管道）和fifo（命名管道）两种，有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。\n2.信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\n3.消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。\n4.信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。\n5.共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。\n6.套接字（socket）：即套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。"
		},{
			"title": "JAVA进程与线程",
			"problem": "什么是线程池？为什么要用线程池？",
			"answer": "线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。\n1.降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n2.提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。\n3.提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。"
		},{
			"title": "JAVA进程与线程",
			"problem": "实现Runnable接⼝和Callable接⼝的区别？",
			"answer": "Runnable ⾃Java 1.0以来⼀直存在，但 Callable 仅在Java 1.5中引⼊,⽬的就是为了来处理 Runnable 不⽀持的⽤例。 Runnable 接⼝不会返回结果或抛出检查异常，但是 Callable 接⼝可以。所以，如果任务不需要返回结果或抛出异常推荐使⽤ Runnable 接⼝，这样代码看起来会更加简洁。\n工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（ Executors.callable（Runnable task ）或 Executors.callable（Runnable task，Object resule） ）。"
		},{
			"title": "JAVA进程与线程",
			"problem": "同步和异步有何异同，在什么情况下分别使用他们？",
			"answer": "如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 \n当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。"
		},{
			"title": "JAVA进程与线程",
			"problem": "进程与线程的区别是什么？",
			"answer": "线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。另外，也正是因为共享资源，所以线程中执行时一般都要进行同步和互斥。进程和线程的主要差别在于它们是不同的操作系统资源管理方式。"
		},{
			"title": "JAVA进程与线程",
			"problem": "线程有哪些基本状态？",
			"answer": "new:初始状态，线程被构建，但是还没有调用start()方法。\nrunnable:运行状态，java线程将操作系统中的就绪和运行两种状态系统的称作运行中。\nblocked:阻塞状态，表示线程阻塞与锁\nwaiting:等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作\ntime-waiting:超时等待状态，该状态不同于waiting,它是可以在指定的时间自行返回的\nterminated:终止状态，表示当前线程已经执行完毕。\n总结：线程创建之后它将处于初始状态，调用start()方法后开始运行，线程这时候处于ready状态。可运行状态的线程获得了CPU时间片后就处于运行状态。当线程执行wait()方法之后，线程进入waiting状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，比如通过sleep方法或wait方法可以将java线程置于超时等待状态。当超时时间到达后java线程将会返回到运行状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行run方法之后将会进入到终止状态。"
		},{
			"title": "JAVA进程与线程",
			"problem": "线程同步问题，自增是原子操作吗？",
			"answer": "自增当然不是原子的，如果对某个对象的某个域进行自增操作。\n1.先要ALOAD 对象\n2.然后DUP一个对象(value)\n3.获得要自增的域的值GETFIELD\n4.在操作栈上压入一个常量1, xCONST_1\n5.做加一的操作xADD\n6.写回自增后的值PUTFIELD"
		},{
			"title": "JAVA进程与线程",
			"problem": "要做到线程安全的自增要做怎么做？",
			"answer": "说明要解决自增操作在多线程环境下线程不安全的问题，可以选择使用Java提供的原子类或者使用synchronized同步方法。而使用volatile关键字, 并不能解决非原子操作的线程安全性。\n另外: 虽然递增操作++i看上去只是一个操作, 但这个操作并非原子的, 因而它并不会作为一个不可分割的操作来执行。\n实际上它包含了三个独立的操作: 读取count的值, 将值加1, 然后将计算结果写入count. 这是一个“读取 - 修改 - 写入”的操作序列, 并且其结果状态依赖于之前的状态。\n补充:\nvolatile变量具有synchronized的可见性特性, 但是不具备原子特性。\nvolatile变量可用于提供线程安全, 但是应用场景非常局限: 多个变量之间或者某个变量的当前值与修改后值之间没有约束。\n因此, 单独使用volatile还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式."
		},{
			"title": "JAVA进程与线程",
			"problem": "多线程间 如何信息通信？如何保证线程安全？",
			"answer": "多线程之间通讯，其实就是多个线程在操作同一个资源，但是操作的动作不同。 \n多线程通讯方式：\nwait()：当前线程等待，类似于sleep(),可以让当前线程，从运行状态变为阻塞(休眠)状态，wait()使用在多线程之间同步，和synchronzied一起使用。注：wait()和sleep()的区别？对于sleep()，我们首先要知道改方法属于Thread类中，而wait()属于object类中。sleep()导致了程序暂停执行指定的时间，让出CPU给其他线程，到了指定的时间，又会自动恢复运行状态。sleep()不会释放锁，wait()可以释放锁。\nnotify()：和wait()一起使用，唤醒使用wait()等待的线程，线程状态从阻塞变为运行。notifyAll()：效果跟notify()一样，notify()唤醒单个线程，notifyAll()唤醒多个线程。"
		},{
			"title": "JAVA进程与线程",
			"problem": "执⾏execute()⽅法和submit()⽅法的区别是什么呢？",
			"answer": "1. execute() ⽅法⽤于提交不需要返回值的任务，所以⽆法判断任务是否被线程池执⾏成功与否；\n2. submit() ⽅法⽤于提交需要返回值的任务。线程池会返回⼀个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执⾏成功，并且可以通过 Future 的 get() ⽅法来获取返回值， get() ⽅法会阻塞当前线程直到任务完成，⽽使⽤ get（long timeout，TimeUnit unit） ⽅法则会阻塞当前线程⼀段时间后⽴即返回，这时候有可能任务没有执⾏完。"
		},{
			"title": "JAVA进程与线程",
			"problem": "synchronized关键字？",
			"answer": "（1）对synchronized关键字的了解\nsynchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。另外，在java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁是依赖于底层的操作系统的Mutex Lock来实现的，java的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，需要相对比较长的时间，这也是为什么synchronized效率低的原因。java6之后官方从jvm层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错。\n（2）synchronized关键字最主要的三种使用方式\n1.修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁\n2.修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员。访问静态synchronized方法占用的锁是当前类的锁，而访问费静态synchronized方法占用的锁是当前实例对象锁。\n3.修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。\n总结：synchronized关键字加到static静态方法和synchronized代码块上都是给Class类上锁。synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用synchronized（String a） 因为jvm中，字符串常量池具有缓存功能。\n（3）synchronized底层原理\nsynchronized 关键字底层原理属于 JVM 层面。\n1.synchronized 同步语句块的情况,synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中 monitorenter指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行\nmonitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种⽅式获取锁的，也是为什么Java中任意对象可以作为锁的原因)的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。\n2.synchronized 修饰⽅法的的情况\nsynchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\n（4）说说jdk1.6之后的synchronized关键字底层做了哪些优化，可以详细介绍一下这些优化吗?JDK1.6 对锁的实现引⼊了⼤量的优化，如偏向锁、轻量级锁、⾃旋锁、适应性⾃旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\n（5）谈谈synchronized和reentrantlock的区别\n① 两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\n② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的\n③ ReentrantLock 比 synchronized 增加了一些高级功能，相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）"
		},{
			"title": "JAVA进程与线程",
			"problem": "synchronized与reteenlock的区别与联系？",
			"answer": "1.synchronized是关键字，就和if...else...一样，是语法层面的实现，因此synchronized获取锁以及释放锁都是Java虚拟机帮助用户完成的；ReentrantLock是类层面的实现，因此锁的获取以及锁的释放都需要用户自己去操作。特别再次提醒，ReentrantLock在lock()完了，一定要手动unlock()，一般放在finally语句块中。\n2.synchronized简单，简单意味着不灵活，而ReentrantLock的锁机制给用户的使用提供了极大的灵活性。这点在Hashtable和ConcurrentHashMap中体现得淋漓尽致。synchronized一锁就锁整个Hash表，而ConcurrentHashMap则利用ReentrantLock实现了锁分离，锁的只是segment而不是整个Hash表\n3.synchronized是不公平锁，而ReentrantLock可以指定锁是公平的还是非公平的\n4.synchronized实现等待/通知机制通知的线程是随机的，ReentrantLock实现等待/通知机制可以有选择性地通知\n5.和synchronized相比，ReentrantLock提供给用户多种方法用于锁信息的获取，比如可以知道lock是否被当前线程获取、lock被同一个线程调用了几次、lock是否被任意线程获取等等\n总结起来，我认为如果只需要锁定简单的方法、简单的代码块，那么考虑使用synchronized，复杂的多线程处理场景下可以考虑使用ReentrantLock。"
		},{
			"title": "JAVA进程与线程",
			"problem": "ReentrantLock 公平锁与非公平锁？",
			"answer": "通过分析ReentrantLock中的公平锁和非公平锁的实现，其中tryAcquire是公平锁和非公平锁实现的区别，下面的两种类型的锁的tryAcquire的实现，从中我们可以看出在公平锁中，每一次的tryAcquire都会检查CLH队列中是否仍有前驱的元素，如果仍然有那么继续等待，通过这种方式来保证先来先服务的原则；而非公平锁，首先是检查并设置锁的状态，这种方式会出现即使队列中有等待的线程，但是新的线程仍然会与排队线程中的对头线程竞争（但是排队的线程是先来先服务的），所以新的线程可能会抢占已经在排队的线程的锁，这样就无法保证先来先服务，但是已经等待的线程们是仍然保证先来先服务的，所以总结一下公平锁和非公平锁的区别：\n1、公平锁能保证：老的线程排队使用锁，新线程仍然排队使用锁。\n2、非公平锁保证：老的线程排队使用锁；但是无法保证新线程抢占已经在排队的线程的锁。"
		},{
			"title": "JAVA进程与线程",
			"problem": "介绍一下Voliate？不能实现什么？",
			"answer": "volatile关键字是用来保证有序性和可见性的。这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高CPU的执行效率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有happens-before规则，其中有条就是volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先Java内存模型分为，主内存，工作内存。比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。 考点：java关键字synchronized修饰静态方法以及同步代码块的synchronized 用法锁的是类，线程想要执行对应同步代码，需要获得类锁。synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。"
		},{
			"title": "JAVA进程与线程",
			"problem": "Android进程优先级管理方式？",
			"answer": "1.前台进程：\n(1)可以看到的/可以操作的/属于前台进程\n(2)A应用 去绑定 B应用的服务，然后B应用是回到桌面状态的，B应用也属性前台进程\n(3)只要是Service在执行生命周期方法的时候，也属于前台进程\n(4)只要是BroadcastReceiver-->onReceiver()生命周期方法的时候，也属于前台进程\n2.可视进程：\n(1)当A应用 被 B应用挡住来一部分， A应用可以看到，却不能操作，A应用属于可视进程\n(2)当A应用 被 B应用挡住来一部分， A应用可以看到，却不能操作，同时A应用绑定了S应用的Service，那么S应用和A应用都属于可视进程\n3.服务进程：\n(1)当C应用启动了一个Service，C应用回到桌面，C应用属于服务进程\n4.后台进程：\n(1)当D应用的任务栈还有Activity应用，D应用回到桌面，D应用属于后台进程（直接按了Home键盘）\n5.空进程：\n(1)当F应用的任务栈被弹栈弹完了，没有一个任务栈了，F应用属于空进程（不停的按Back键） "
		},{
			"title": "JAVA进程与线程",
			"problem": "什么是线程和进程？",
			"answer": "进程：是程序的一次执行过程 & 是系统运行程序的基本单位，系统运行一个程序即是一个进程从创建，运行到消亡的过程。\n作用：使多个程序可 并发执行，以提高系统的资源利用率和吞吐量\n线程：一个基本的CPU执行单元 & 程序执行流的最小单元\n作用：减少程序在并发执行时所付出的时空开销，提高操作系统的并发性能。"
		},{
			"title": "JAVA进程与线程",
			"problem": "请简要描述线程与进程的关系，区别及优缺点？",
			"answer": "线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反"
		},{
			"title": "JAVA进程与线程",
			"problem": "说说并发与并行的区别？",
			"answer": "并发：同一时间段，多个任务都在执行\n\t并行：单位时间内，多个任务同时执行\n\t例子：如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统"
		},{
			"title": "JAVA进程与线程",
			"problem": "为什么要使用多线程呢？",
			"answer": "从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调\n度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上\n下文切换的开销。\n\t从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程\n并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及\n性能\n\t单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。\n\t多核时代:  多核时代多线程主要是为了提高 CPU 利用率。"
		},{
			"title": "JAVA进程与线程",
			"problem": "使用多线程可能带来什么问题？",
			"answer": "并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。"
		},{
			"title": "JAVA进程与线程",
			"problem": "说说线程的生命周期和状态？",
			"answer": "线程创建之后它将处于 NEW（新建） 状态，调用start()方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于RUNNING（运行） 状态。当线程执行 wait() 方法之后，线程进行WAITING（等待） 状态。进行等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，⽽而TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis） 方法或 wait（long millis） 方法可以将 Java线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行Runnable 的 run() 方法之后将会进入到 TERMINATED（终止） 状态。"
		},{
			"title": "JAVA进程与线程",
			"problem": "什么是上下文切换？",
			"answer": "当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。"
		},{
			"title": "JAVA进程与线程",
			"problem": "什么是线程死锁，如何避免死锁？",
			"answer": "多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。\n\t（1）如何避免线程死锁。\n产生死锁必须具备的四个条件：\n1.互斥条件：该资源任意一个时刻只由一个线程占用\n2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n3.不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\n4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。破坏产生死锁的四个条件中的其中一个就可以了。\n1.破坏互斥条件：没有办法破坏，因为我们用锁本来就是想让他们互斥的。\n2.破坏请求与保持条件：一次性申请所有的资源\n3.破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有资源。\n4.破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循坏等待条件。"
		},{
			"title": "JAVA进程与线程",
			"problem": "说说sleep方法和wait方法区别和共同点？",
			"answer": "1.两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁。\n\t2.两者都可以暂停线程的执行\n\t3.wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。\n\t4.wait方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify或者notifyAll方法。\n\t5.sleep方法执行完成后，线程会自动苏醒。或者可以使用wait超时后线程会自动苏醒。"
		},{
			"title": "JAVA进程与线程",
			"problem": "为什么我们不能直接调用run方法？",
			"answer": "调用 start 方法方可启动线程并使线程进入就绪状态，而run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。"
		},{
			"title": "JAVA进程与线程",
			"problem": "volatile关键字？",
			"answer": "（1）介绍下java内存模型\n在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。\n（2）并发编程三个重要特性\n1. 原子性 : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。 synchronized 可以保证代码片段的原子性。\n2. 可见性 ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。 volatile 关键字可以保证共享变量的可见性。\n3. 有序性 ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。 volatile 关键字可以禁止指令进行重排序优化。\n（3）说说synchronized关键字和volatile关键字的区别\nsynchronized关键字和volatile关键字比较 \nvolatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用synchronized 关键字的场景还是更多一些。多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。volatile关键字主要⽤于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。"
		},{
			"title": "JAVA进程与线程",
			"problem": "Threadlocal？",
			"answer": "多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。ThreadLocal是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法，当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题。"
		},{
			"title": "JAVA进程与线程",
			"problem": "如何创建线程池？",
			"answer": "方式一：通过构造方法实现 \n方式二：通过Executor 框架的工具类Executors来实现 .\nExecutors 返回线程池对象的弊端如下：\nFixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。\nCachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。"
		}
	]
}
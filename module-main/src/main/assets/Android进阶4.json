{
  "code": 200,
  "message": "",
  "body": [
    {
      "title": "Android进阶1",
      "problem": "介绍一下Handler消息机制（原理）？",
      "answer": "1.Android中主线程是不能进行耗时操作的，子线程是不能进行更新UI的。且为了多个线程并发更新UI的同时 保证线程安全的情况下，所以就有了handler，它的作用就是实现线程之间的通信。\n2.handler整个流程中，主要有四个对象，handler，Message,MessageQueue,Looper。首先创建一个Message对象用来保存我们需要发送的内容。然后通过handler对象的sendMessage方法将Message发送到MessageQueue中,MessageQueue是负责管理存储handler发送过来的消息。再通过Loop对象调用loop方法不断的从MessageQueue中取出Message交给handler的handleMessage方法进行处理。从而实现线程之间的通信。loop被称为循环器，主要是从消息队列中获取消息交给handle处理。"
    },
    {
      "title": "Android进阶1",
      "problem": "介绍一下事件的分发机制？",
      "answer": "1.本质是将点击事件传递到某个具体View处理的整个过程\n2.事件先传到Activity、再传到ViewGroup、最终再传到 View而事件的分发过程是由Activity、viewGroup、View里面的方法协作完成的\n3.整体流程是：当我们点击屏幕的时候，会产生一个按下的触摸事件。这个事件会先在Activity的dispatchTouchEvent()进行分发然后根据ViewGroup.dispatchTouchEvent()返回结果判断事件是否被处理也就是分发给了ViewGroup.dispatchTouchEvent()；\n如果事件没有在ViewGroup.dispatchTouchEvent()分发过程中处理掉则会交给Activity.onTouchEvent()进行处理这就是Activity的分发过程\n4.在ViewGroup.dispatchTouchEvent（）分发过程中，会判断事件是否被OnInterceptTouchEvent拦截如果事件被拦截则调用ViewGroup.onTouchEvent()对事件进行处理否则会根据View.dispatchTouchEvent来判断事件有没有被处理掉，也就是分发给了View.dispatchTouchEvent（）如果事件没在View.dispatchTouchEvent分发过程中处理，则会调用Activity.onTouchEvent方法进行处理这就是ViewGroup的分发过程\n5.而在View.dispatchTouchEvent（）分发过程中，是调用 了View.onTouchEvent进行处理的如果View.onTouchEvent没有处理点击事件，则交给父类的ViewGrounp.onTouchEvent处理这就是View的分发过程\n6.当按下事件被处理后，会再View上做一个标记位，后续的移动事件与离开事件都会在同一个View上被处理。"
    },
    {
      "title": "Android进阶1",
      "problem": "介绍一下Layout主要有那几个流程？事件冲突和解决？",
      "answer": "1.事件冲突解决：\n内部解决方法：onInterceptTouchEvent\n外部解决方法：requestDisallowInterceptTouchEvent\n2.首次 View 的绘制流程是在什么时候触发的？ViewRootImpl 创建的时机？\n在 ActivityThread.handleResumeActivity 里触发的。ActivityThread.handleResumeActivity 里会调用 wm.addView 来添加 DecorView，wm 是 WindowManagerImpl 。最终通过 WindowManagerImpl.addView -> WindowManagerGlobal.addView -> ViewRootImpl.setView -> ViewRootImpl.requestLayout 就触发了第一次 View 的绘制。\n3.ViewRootImpl 和 DecorView 的关系是什么？\n所以 ViewRootImpl 和 DecorView 的关系就是 ViewRootImpl 是 DecorView 的 parent。 \n4.performLayout---View.layout ---onLayout"
    },
    {
      "title": "Android进阶1",
      "problem": "介绍一下view的绘制流程？",
      "answer": "1.我们知道每个Activity 均会创建一个 PhoneWindow对象，是Activity和整个View系统交互的接口，每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系,对于Activity来说，ViewRootImpl是连接WindowManager和DecorView的纽带,绘制的入口是由ViewRootImpl的performTraversals方法来发起Measure，Layout，Draw等流程的。\n2.首先是根据之前的状态判断是否需要重新 测量，是否需要重新调整位置，是否需要重新绘制。\n3.测量是从Measure方法开始的。父 View 先测量子 View，等子 View 测量完了，再来测量自己。在方法里面会调用 onMeasure方法，onMeasure方法就是执行测量设置 View 代码的核心，在onMeasure里面，获取到最小建议值，如果父类传递过来的模式是MeasureSpec.UNSPECIFIED，也就是父View大小未定的情况下，使用最小建议值，如果是AT_MOST或者EXACTLY模式，则设置父类传递过来的大小。然后调用setMeasuredDimension 方法进行存储大小。\n4.当我们已经测量出View的大小，根据这些大小，我们接下来就可以确定 View 在父 View 的位置，布局的调整是从layout方法开始。在方法里面会调用 onLayout方法也就是布局的核心方法。遍历每个子view进行布局。\n5.当我们确定完位置后就可以开始在屏幕上绘制我们所需要的的图形了。这时就会调用到draw方法。首先是绘制 View 的背景。然后调用onDraw()绘制具体内容。接着绘制所有子View。再绘制滚动条等其他内容。\n"
    },
    {
      "title": "Android进阶1",
      "problem": "介绍一下binder机制？",
      "answer": "1.是android中实现IPC的方式\n2.从组成来看连接了Service进程、Client进程和ServiceManager进程\n3.原理：\n注册服务：\n（1）服务进程向Binder驱动发起服务注册请求\n（2）Binder驱动将注册请求转发给服务管理进程\n（3）服务管理进程负责管理注册已注册的服务。\n获取服务：\n（1）客户进程向Binder驱动发起获取服务请求，传递要获取的服务名称\n（2）Binder驱动将该请求转发给服务管理进程\n（3）服务管理进程查找到客户进程需要的服务信息\n（4）通过Binder驱动将上述服务信息返回给客户进程\n使用服务：\n（1）binder驱动再内核空间创建一个的接收缓存区。根据服务管理进程里的服务信息找到对应的服务进程。实现内核缓存区和服务进程用户空间地址同时映射到接收缓存区中\n（2）客户进程通过系统调用Copy_from_user方法发送数据到内核空间中的缓存区，因存在映射关系。相当于发送到了服务进程的用户空间地址，然后binder驱动通知服务进程执行解包\n（3）收到Binder驱动通知后，服务进程从线程池中取出线程，进行数据解包。调用目标方法。将最终执行结果写入到自己的共享内存中\n（4）binder驱动通知客户进程获得返回结果，客户进程通过系统调用Copy_to_user方法从内核缓存区接收服务进程返回的数据。"
    },
    {
      "title": "Android进阶1",
      "problem": "介绍一下context继承图？",
      "answer": "Context的直接子类有两个，一个是ContextWrapper，一个是ContextImpl。那么从名字上就可以看出，ContextWrapper是上下文功能的封装类，而ContextImpl则是上下文功能的实现类。ContextWrapper又有三个直接的子类，ContextThemeWrapper、Service和Application。其中，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity。在这里我们看到了几个所比较熟悉的面孔，Activity、Service、还有Application。由此，我们可以大致得出结论，Context一共有三种类型，分别是Application、Activity和Service。"
    },
    {
      "title": "Android进阶1",
      "problem": "IntentService用法？",
      "answer": "1.IntentService是一个继承service，并处理异步操作的一个类。它在onCreate()方法中创建了一个HandlerThread,并启动该线程。HandlerThread是带有自己消息队列和Looper的线程，根据HandlerThread的looper创建一个Handler，这样IntentService的ServiceHandler的handleMessage()方法就运行在子线程中。handleMessage中调用了onHandleIntent()方法，它是一个抽象方法，继承IntentService类需要实现该方法，把耗时操作放在onHandleIntent()方法中，等耗时操作运行完成后，会调用stopSelf()方法，服务会调用onDestory()方法消毁自己。如果onHandleIntent()中的耗时操作未运行完前就调用了stopSelf()方法，服务调用onDestory()方法，但耗时操作会继续运行，直至运行完毕。如果同时多次启动IntentService，任务会放在一个队列中，onCreate()和onDestory()方法都只会运行一次。\n2.在IntentService内有一个工作线程来处理耗时操作，启 动IntentService的方式和启动传统Service一样。当这个耗时操作处理完成后，服务会自动关闭，而不需要我们去手动控制。可以多次启动IntentService，所有的耗时任务会以队列的形式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推。所有的请求都在   单线程中执行，不会阻塞主线程。同一时间只能处理一个请求。\n优点（1）不需要主动去创建线程。（2）不需要手动去停止线程，执行完会自动关闭。（3）Android 8.0之后建议使用WorkManager\n"
    },
    {
      "title": "Android进阶1",
      "problem": "介绍一下屏幕横竖屏切换 时的生命周期变化？",
      "answer": "ps:①不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 \n②设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 \n③设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法"
    },
    {
      "title": "Android进阶1",
      "problem": "介绍一下ContentProvider？",
      "answer": "1.作用：进程间进行数据交互 & 共享，即跨进程通信\n2.原理：Android中的Binder机制\n3.ContentProvider实现各个应用程序间数据共享，用来提供内容给别的应用操作。如联系人应用中就使用了ContentProvider，可以在自己应用中读取和修改联系人信息，不过需要获取相应的权限。它也只是一个中间件，真正的数据源是文件或SQLite等。\n4.ContentResolver内容解析者，统一管理不同 ContentProvider间的操作（1）通过 URI 即可操作 不同的ContentProvider 中的数据（2）外部进程通过 ContentResolver类 从而与ContentProvider类进行交互\n5.ContentObserver内容监听者，可以监听数据的改变状态，观察特定Uri引起的数据库变化，继而做一些相应的处理，类似于数据库中的触发器，当ContentObserver所观察的Uri发生变化时，便会触发它。\n6.优点：安全：允许把自己的应用数据根据需求开放给 其他应用 进行 增、删、改、查，而不用担心因为直接开放数据库权限而带来的安全问题"
    },
    {
      "title": "Android进阶1",
      "problem": "介绍一下安卓11有什么新的特性？",
      "answer": "从兼容性方面来讲分为两部分：\n1.应用兼容手机版本为Android 11的\n（1）隐私设置：单次授权；权限对话框的可见性；数据访问审核；系统提醒窗口权限\n（2）安全性：应用使用情况统计信息；SSL 套接字默认情况下使用 Conscrypt SSL 引擎\n（3）性能和调试：JobScheduler API 调用限制调试；文件描述符排错程序 ；\n（4）与其他应用交互：分享内容 URI\n2.以android 11 为 目标的应用\n（1）隐私设置：强制执行分区存储；自动重置权限；在后台访问位置信息的权限；软件包可见性\n（2）安全：应用从后台发送的自定义视图的消息框，系统会屏蔽这些消息框\n（4）必须具备 Manifest.permission.WRITE_APN_SETTINGS 特权，才能读取或访问电话提供程序 APN 数据库\n（5）文字转语音 (TTS) 引擎交互的应用需要声明queries标签\n（6）应用打包和安装：应用包含压缩的 resources.arsc 文件或者如果此文件未按 4 字节边界对齐，应用将无法安装；用户无法在搭载 Android 11 的设备上安装或更新仅通过 APK 签名方案 v1 签名的应用。"
    },    {
      "title": "Android进阶2",
      "problem": "介绍一下Activity的 四种启动模式，原理是怎样的？",
      "answer": "当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 。\n1.stantder（标准模式）：每启动一次Activity，就会创建一个新的Activity实例并置于栈顶。\n2.singleTop（栈顶复用模式）：若启动的Activity位于任务栈栈顶，则复用栈顶的实例。否则就会创建一个新的Activity实例并置于栈顶。( 调用实例的 onNewIntent() 、不调用onCreate()和onStart())\n3.singleTask（栈内复用模式）：若启动的Activity在栈内，则将该实例置于栈顶，并移除原先Activity位置上层的Activity。否则就会创建一个新的Activity实例并置于栈顶。\n4.singleInstance（单例模式）：若启动的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用。否则就会创建一个新的任务栈，并创建该Activity实例放入新栈中。"
    },
    {
      "title": "Android进阶2",
      "problem": "介绍一下SingleTop和SingleTask启动模式的应用场景？",
      "answer": "singleTop：消息推送界面\nsingleTask:MainActivity主界面"
    },
    {
      "title": "Android进阶2",
      "problem": "谈谈Android的IPC（进程间通信）机制？",
      "answer": "1.IPC是内部进程通信的简称， 是共享&quot;命名管道&quot;的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。"
    },
    {
      "title": "Android进阶2",
      "problem": "介绍一下安卓中有哪些 进程间通信 的方式？",
      "answer": "1.使用Bundle：三大组件都支持在Intent中传递Bundle数据，由于Bundle实现了Parcelable接口，所以他可以方便的在不同的进程之间进行传输\n2.使用文件共享：两个进程通过读/写同一个文件来交换数据\n3.使用Messenger：\n4.使用AIDL：是一种接口定义语言，用于生成可以在Android设备上两个进程之间进行进程间通信(IPC)的代码\n5.使用ContentProvider：实现数据共享\n6.使用广播：当某个程序向系统发送广播时，其他的应用程序只能被动地接收广播数据\n7.使用Socket：进行网络通信"
    },
    {
      "title": "Android进阶2",
      "problem": "介绍一下app如何开启多个进程？",
      "answer": "1.四大组件在AndroidMenifest中指定android:process属性\n（1）未指明android:process属性，它允许在默认进程中，进程名为包名\n（2）设置android:process=\":remote\"，系统会为它创建一个单独的进程，进程名为包名＋:remote\n（3）设置android:process=\"com.zhong.remote\",系统会为它创建一个单独的进程，进程名为process设置的值"
    },
    {
      "title": "Android进阶2",
      "problem": "介绍一下每个进程都是在独立的虚拟机上吗？",
      "answer": "1.独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。\n2.不同的应用在不同的进程空间里运行，当一个虚拟机关闭或意外中止时不会对其它 虚拟机造成影响，可以最大程度的保护应用的安全和独立运行\n3.Dalvik负责进程隔离和线程管理，每一个android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行"
    },
    {
      "title": "Android进阶2",
      "problem": "介绍一下进程和线程的区别？",
      "answer": "1.进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程\n2.是一个具有独立功能的程序关于某个数据集合的一次运行活动。进程是系统进行资源分配和调度的一个独立单位。可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体，是一个“执行中的程序”\n3.线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程比进程更小，基本上不拥有系统资源，故对它的调度所用资源小，能更高效的提高系统内多个程序间并发执行的\n\n4.区别：\n（1）子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。\n（2）进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。\n（3）进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。\n（4）线程上下文切换比进程上下文切换要快得多。"
    },
    {
      "title": "Android进阶2",
      "problem": "介绍一下camera水波纹产生的原因？",
      "answer": "相机在拍摄画面时往往在预览界面出现波纹现象，出现这种现象主要是因为预览与拍摄画面存在刷新帧率差异以及感光元件出现干扰等引起。主要分为以下三种：\n(1)手机预览刷新频率与所拍摄物体刷新帧率不同步(比如使用手机拍摄电视或者日光灯出现闪动波纹)当我们使用手机相机对准电视或日光灯时，我们可以看到预览界面有类似于水波纹的明暗条纹。\n出现这种情况是因为手机预览刷新的帧率与拍摄物体刷新帧率不同步导致的。日光灯的帧率一般为50HZ，如果需要避免这种情况将相机的避免闪烁功能设置为50HZ即可\n(2)莫尔条纹影响:莫尔条纹是两条线或两个物体之间以恒定的角度和频率发生干涉的视觉结果(详细描述可以查看百科)。\n当使用相机对这电视屏幕拍照时，预览会显示类似于下图的明暗相见的条纹。\n(3)摩尔纹现象:摩尔现象是一种视觉现象，在有一定间隔的物体上发生的干涉条纹。摩尔纹泛指两个频率接近的等幅正弦波叠加而产生的干涉条纹。"
    },
    {
      "title": "Android进阶2",
      "problem": "介绍一下子一个线程可否有多个Handler，怎么保证只有一个Looper？",
      "answer": "1.因为Handler可以在Activity可以new，在Service里面也可以new，而Activity全部都跑在了主线程里面，这就证明了主线程中可以有多个Handler\n2.如何保证一个线程中只有一个Looper\n一个线程跟一个ThreadLocalMap是绑定的，如果这个Map中存有当前Looper里的sThreadLocal为键的键值对，就不会再存储Looper，反而会抛异常了。反之，就会存入当前Looper里的sThreadLocal为键，new Looper(quitAllowed)为值的对。"
    },
    {
      "title": "Android进阶2",
      "problem": "介绍一下Handler和AsynTask的区别？",
      "answer": "1.AsyncTask实现的原理,和适用的优缺点：\nAsyncTask,是android提供的轻量级的异步类,可以直接继承AsyncTask,在类中实现异步操作,并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新),最后反馈执行的结果给UI主线程.\n缺点：在使用多个异步操作和并需要进行Ui变更时,就变得复杂起来.\n2.Handler异步实现的原理和适用的优缺点：\n在Handler 异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程）àthread(子线程)运行并生成Message-àLooper获取Message并传递给HandleràHandler逐个获取Looper中的Message，并进行UI变更\n缺点：在单个后台异步处理时，显得代码过多，结构过于复杂（相对性）"
    }
  ]
}